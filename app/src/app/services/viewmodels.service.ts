import { EventEmitter, Injectable, Output } from "@angular/core";
import { Tactic } from "../classes/stix/tactic";
import { Technique } from "../classes/stix/technique";
@Injectable({
  providedIn: 'root'
})
export class ViewModelsService {
  @Output() onSelectionChange = new EventEmitter<any>();
  pinnedCell = "";
  viewModels: ViewModel[] = [];

  constructor(){}

  /**
   * Emit event when technique selection changes
   */
  selectionChanged() {
      this.onSelectionChange.emit();
  }

  /**
   * Create and return a new viewModel
   * @param {string} name the viewmodel name
   * @param {string} domainVersionID the ID of the domain & version
   * @return {ViewModel} the created ViewModel
   */
  newViewModel(name: string) {
    let vm = new ViewModel(
      name, "vm"+ this.getNonce(),
      []
    )
      this.viewModels.push(vm);
      return vm;
  }

  nonce: number = 0;
  /**
   * Get a nonce.
   * @return a number that will never be regenerated by sequential calls to getNonce.
   *         Note: this applies on a session-by-session basis, nonces are not
   *         unique between app instances.
   */
  getNonce(): number {
      return this.nonce++;
  }
  /**
   * Destroy the viewmodel completely Nessecary if tab is closed!
   * @param vm viewmodel to destroy.
   */
  destroyViewModel(vm: ViewModel): void {
    for (let i = 0; i < this.viewModels.length; i++) {
        if (this.viewModels[i] == vm) {
            // console.log("destroying viewmodel", vm)
            this.viewModels.splice(i,1)
            return;
        }
    }
  }
}

export class ViewModel {
    // PROPERTIES & DEFAULTS

    name: string; // layer name
    domain: string = ""; // attack domain
    version: string = ""; // attack version
    domainVersionID: string; // layer domain & version
    description: string = ""; //layer description
    uid: string; //unique identifier for this ViewModel. Do not serialize, let it get initialized by the VmService
    selectTechniquesAcrossTactics: boolean = true;
    selectSubtechniquesWithParent: boolean = false;
    techiqueTacticIds: string[];

    constructor(name: string, uid: string, techiqueTacticIds: string[]){
      console.log("initializing ViewModel '" + name + "'");
      this.name = name;
      this.uid = uid;
      this.techiqueTacticIds = techiqueTacticIds;
    }
    // initialize information for view model
    loadVMData() {
      let self = this;
      self.initTechniqueVMs();
    }
    initTechniqueVMs() {
      console.log(this.name, "initializing technique VMs");

    }
    needsToConstructTechniqueVMs = false;
    legacyTechniques = [];

    public highlightedTactic: Tactic = null;
    public highlightedTechniques: Set<string> = new Set<string>();
    public highlightedTechnique: Technique = null; // the Technique that was actually moused over

  /**
   * Highlight the given technique under the given tactic
   * @param {Technique} technique to highlight
   * @param {Tactic} tactic wherein the technique occurs
   */
    public highlightTechnique(technique: Technique, tactic?: Tactic | null) {
        this.highlightedTechnique = technique;
        this.highlightedTechniques.add(technique.attackID);
        this.highlightedTactic = tactic;
    }
    /**
     * Clear the technique highlight
     */
    public clearHighlight() {
      this.highlightedTactic = null;
      this.highlightedTechnique = null;
      this.highlightedTechniques = new Set<string>();
  }
  private selectedTechniques: Set<string> = new Set<string>();
    /**
     * Select the given technique. Depending on selectTechniquesAcrossTactics, either selects in all tactics or in given tactic
     * @param {Technique} technique to select
     * @param {Tactic} tactic wherein the technique occurs
     */
    public selectTechnique(technique: Technique, tactic: Tactic): void {
      if (this.selectTechniquesAcrossTactics) this.selectTechniqueAcrossTactics(technique);
      else (this.selectTechniqueInTactic(technique, tactic));
  }
  /**
       * select the given technique across all tactics in which it occurs
       * @param {Technique} technique to select
       * @param {boolean} walkChildren (recursion helper) if true and selectSubtechniquesWithParent is true, walk selection up to parent technique
       * @param highlightTechniques, if true, highlight techniques rather than add to selected techniques group
       */
  public selectTechniqueAcrossTactics(technique: Technique, walkChildren= true, highlightTechniques = false): void {
    if (this.selectSubtechniquesWithParent && walkChildren) { //walk to parent / children / siblings
        if (technique.is_subtechnique) { //select from parent
            // this.selectTechniqueAcrossTactics(technique.parent, true, highlightTechniques);
            return;
        } else { //select subtechniques
            // for (let subtechnique of technique.subtechniques) {
            //     this.selectTechniqueAcrossTactics(subtechnique, false, highlightTechniques);
            // }
        }
    }
    if (highlightTechniques) {
        this.highlightTechnique(technique);
    }
    else {
        for (let id of technique.get_all_technique_tactic_ids()) {
            // if (!this.isCurrentlyEditing()) this.activeTvm = this.getTechniqueVM_id(id); // first selection
            this.selectedTechniques.add(id);
            // this.checkValues(true, id);
        }
    }
  }
      /**
     * select the given technique in the given tactic
     * @param {Technique} technique to select
     * @param {Tactic} tactic wherein the technique occurs
     * @param {boolean} walkChildren (recursion helper) if true and selectSubtechniquesWithParent is true, walk selection up to parent technique
     */
      public selectTechniqueInTactic(technique: Technique, tactic: Tactic, walkChildren=true): void {
        if (this.selectSubtechniquesWithParent && walkChildren) { //check parent / children / siblings
            if (technique.is_subtechnique) { //select from parent
                // this.selectTechniqueInTactic(technique.parent, tactic, true);
                return;
            } else { //select subtechniques
                // for (let subtechnique of technique.subtechniques) {
                //     this.selectTechniqueInTactic(subtechnique, tactic, false);
                // }
            }
        }
        let technique_tactic_id = technique.get_technique_tactic_id(tactic);
        // if (!this.isCurrentlyEditing()) this.activeTvm = this.getTechniqueVM_id(technique_tactic_id); // first selection
        this.selectedTechniques.add(technique_tactic_id);
        // this.checkValues(true, technique_tactic_id);
    }

  /**
   * unselect all techniques
   */
    public clearSelectedTechniques() {
      this.selectedTechniques.clear();
      // this.activeTvm = undefined;
      // this.linkMismatches = [];
      // this.metadataMismatches = [];
  }

  /**
   * Select all techniques
   */
  public selectAllTechniques(): void {
      this.clearSelectedTechniques()
      this.invertSelection();
  }
      /**
   * Set all selected techniques to deselected, and select all techniques not currently selected
   */
      public invertSelection(): void {
        // let previouslySelected = new Set(this.selectedTechniques);
        // this.clearSelectedTechniques();
        // let self = this;
        // this.techniqueVMs.forEach(function(tvm, key) {
        //     if (!previouslySelected.has(tvm.technique_tactic_union_id)) {
        //         if (!self.isCurrentlyEditing()) self.activeTvm = self.getTechniqueVM_id(tvm.technique_tactic_union_id); // first selection
        //         self.selectedTechniques.add(tvm.technique_tactic_union_id);
        //         self.checkValues(true, tvm.technique_tactic_union_id);
        //     }
        // });
    }

  techniqueVMs: Map<string, TechniqueVM> = new Map<string, TechniqueVM>(); //configuration for each technique
  public getTechniqueVM(technique: Technique, tactic: Tactic) : TechniqueVM {
    console.log("technique vm ", this.techniqueVMs);

    if (!this.hasTechniqueVM(technique, tactic)) throw Error("technique VM not found: " + technique.attackID + ", " + tactic.attackID);
    return this.techniqueVMs.get(technique.get_technique_tactic_id(tactic))
  }
  public getTechniqueVM_id(technique_tactic_id: string): TechniqueVM {
    if (!this.hasTechniqueVM_id(technique_tactic_id)) throw Error("technique VM not found: " + technique_tactic_id);
    return this.techniqueVMs.get(technique_tactic_id);
  }

  public hasTechniqueVM(technique: Technique, tactic: Tactic): boolean {
    return this.techniqueVMs.has(technique.get_technique_tactic_id(tactic));
  }
  public hasTechniqueVM_id(technique_tactic_id: string): boolean {
    return this.techniqueVMs.has(technique_tactic_id);
  }
}
export class TechniqueVM {
  techniqueID: string;
  technique_tactic_union_id: string;
  tactic: string;

  score: string = "";
  scoreColor: any; //color for score gradient

  color: string = ""; //manually assigned color-class name
  enabled: boolean = true;
  comment: string = ""
  showSubtechniques = false;

    /**
     * Has this TechniqueVM been modified from its initialized state?
     * @return true if it has been modified, false otherwise
     */
    modified(): boolean {
      return (this.annotated() || this.showSubtechniques);
  }

  /**
   * Check if this TechniqueVM has been annotated
   * @return true if it has annotations, false otherwise
   */
  annotated(): boolean {
      return (this.score != "" || this.color != "" || !this.enabled || this.comment != "");
  }

  /**
   * Reset this TechniqueVM's annotations to their default values
   */
  resetAnnotations(): void {
    this.score = "";
    this.comment = "";
    this.color = "";
    this.enabled = true;
  }
  constructor(technique_tactic_union_id: string) {
    this.technique_tactic_union_id = technique_tactic_union_id;
    var idSplit = technique_tactic_union_id.split("^");
    this.techniqueID = idSplit[0];
    this.tactic = idSplit[1];
  }
}
