import { EventEmitter, Injectable, Output } from "@angular/core";
import { Tactic } from "../classes/stix/tactic";
import { Technique } from "../classes/stix/technique";
@Injectable({
  providedIn: 'root'
})
export class ViewModelsService {
  @Output() onSelectionChange = new EventEmitter<any>();
  viewModels: ViewModel[] = [];

  constructor(){}

  /**
   * Emit event when technique selection changes
   */
  selectionChanged() {
      this.onSelectionChange.emit();
  }

  /**
   * Create and return a new viewModel
   * @param {string} name the viewmodel name
   * @param {string} domainVersionID the ID of the domain & version
   * @return {ViewModel} the created ViewModel
   */
  newViewModel(name: string) {
    let vm = new ViewModel(
      name, "vm"+ this.getNonce(),
      []
    )
      this.viewModels.push(vm);
      return vm;
  }

  nonce: number = 0;
  /**
   * Get a nonce.
   * @return a number that will never be regenerated by sequential calls to getNonce.
   *         Note: this applies on a session-by-session basis, nonces are not
   *         unique between app instances.
   */
  getNonce(): number {
      return this.nonce++;
  }
  /**
   * Destroy the viewmodel completely Nessecary if tab is closed!
   * @param vm viewmodel to destroy.
   */
  destroyViewModel(vm: ViewModel): void {
    for (let i = 0; i < this.viewModels.length; i++) {
        if (this.viewModels[i] == vm) {
            // console.log("destroying viewmodel", vm)
            this.viewModels.splice(i,1)
            return;
        }
    }
  }
}

export class ViewModel {
    // PROPERTIES & DEFAULTS

    name: string; // layer name
    domain: string = ""; // attack domain
    version: string = ""; // attack version
    domainVersionID: string; // layer domain & version
    description: string = ""; //layer description
    uid: string; //unique identifier for this ViewModel. Do not serialize, let it get initialized by the VmService
    selectTechniquesAcrossTactics: boolean = true;
    selectSubtechniquesWithParent: boolean = false;
    techiqueTacticIds: string[];

    constructor(name: string, uid: string, techiqueTacticIds: string[]){
      console.log("initializing ViewModel '" + name + "'");
      this.name = name;
      this.uid = uid;
      this.techiqueTacticIds = techiqueTacticIds;
    }
    // initialize information for view model
    loadVMData() {
      let self = this;
      self.initTechniqueVMs();
    }
    initTechniqueVMs() {
      console.log(this.name, "initializing technique VMs");

    }
    needsToConstructTechniqueVMs = false;
    legacyTechniques = [];

    public highlightedTactic: Tactic = null;
    public highlightedTechniques: Set<string> = new Set<string>();
    public highlightedTechnique: Technique = null; // the Technique that was actually moused over

  /**
   * Highlight the given technique under the given tactic
   * @param {Technique} technique to highlight
   * @param {Tactic} tactic wherein the technique occurs
   */
    public highlightTechnique(technique: Technique, tactic?: Tactic | null) {
        // if (this.selectSubtechniquesWithParent && technique.is_subtechnique)
        // {
        //   this.highlightedTechniques.add(technique.parent.id);
        // }
        console.log("highlighting technique: ", technique);

        this.highlightedTechnique = technique;
        this.highlightedTechniques.add(technique.attackID);
        this.highlightedTactic = tactic;
        console.log("list ", this.highlightedTechniques)
    }
    /**
     * Clear the technique highlight
     */
    public clearHighlight() {
      this.highlightedTactic = null;
      this.highlightedTechnique = null;
      this.highlightedTechniques = new Set<string>();
  }
}
export class TechniqueVM {
  techniqueID: string;
  technique_tactic_union_id: string;
  tactic: string;

  score: string = "";
  scoreColor: any; //color for score gradient

  color: string = ""; //manually assigned color-class name
  enabled: boolean = true;
  comment: string = ""
  showSubtechniques = false;

    /**
     * Has this TechniqueVM been modified from its initialized state?
     * @return true if it has been modified, false otherwise
     */
    modified(): boolean {
      return (this.annotated() || this.showSubtechniques);
  }

  /**
   * Check if this TechniqueVM has been annotated
   * @return true if it has annotations, false otherwise
   */
  annotated(): boolean {
      return (this.score != "" || this.color != "" || !this.enabled || this.comment != "");
  }

  /**
   * Reset this TechniqueVM's annotations to their default values
   */
  resetAnnotations(): void {
    this.score = "";
    this.comment = "";
    this.color = "";
    this.enabled = true;
  }
  constructor(technique_tactic_union_id: string) {
    this.technique_tactic_union_id = technique_tactic_union_id;
    var idSplit = technique_tactic_union_id.split("^");
    this.techniqueID = idSplit[0];
    this.tactic = idSplit[1];
  }
}
